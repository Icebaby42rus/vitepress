## Типы данных

В JavaScript есть 8 основных типов данных.

<ul>
<li>Семь из них называют «примитивными» типами данных:
<ul>
<li><code>number</code> для любых чисел: целочисленных или чисел с плавающей точкой; целочисленные значения ограничены диапазоном <code>±(2<sup>53</sup>-1)</code>.</li>
<li><code>bigint</code> для целых чисел произвольной длины.</li>
<li><code>string</code> для строк. Строка может содержать ноль или больше символов, нет отдельного символьного типа.</li>
<li><code>boolean</code> для <code>true</code>/<code>false</code>.</li>
<li><code>null</code> для неизвестных значений – отдельный тип, имеющий одно значение <code>null</code>.</li>
<li><code>undefined</code> для неприсвоенных значений – отдельный тип, имеющий одно значение <code>undefined</code>.</li>
<li><code>symbol</code> для уникальных идентификаторов.</li>
</ul>
</li>
<li>И один не является «примитивным» и стоит особняком:
<ul>
<li><code>object</code> для более сложных структур данных.</li>
</ul>
</li>
</ul>

<p>Оператор <code>typeof</code> позволяет нам увидеть, какой тип данных сохранён в переменной.</p>

<ul>
<li>Имеет две формы: <code>typeof x</code> или <code>typeof(x)</code>.</li>
<li>Возвращает строку с именем типа. Например, <code>"string"</code>.</li>
<li>Для <code>null</code> возвращается <code>"object"</code> – это ошибка в языке, на самом деле это не объект.</li>
</ul>

## Преобразование типов

Существует 3 наиболее широко используемых преобразования: строковое, численное и логическое.

- <p><strong><code>Строковое</code></strong> – Происходит, когда нам нужно что-то вывести. Может быть вызвано с помощью <code>String(value)</code>. Для примитивных значений работает очевидным образом.</p>

- <p><strong><code>Численное</code></strong> – Происходит в математических операциях. Может быть вызвано с помощью <code>Number(value)</code>.</p>

Преобразование подчиняется правилам:

<table>
<thead>
<tr>
<th>Значение</th>
<th>Становится…</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>undefined</code></td>
<td><code>NaN</code></td>
</tr>
<tr>
<td><code>null</code></td>
<td><code>0</code></td>
</tr>
<tr>
<td><code>true&nbsp;/&nbsp;false</code></td>
<td><code>1 / 0</code></td>
</tr>
<tr>
<td><code>string</code></td>
<td>Пробельные символы по краям обрезаются. Далее, если остаётся пустая строка, то получаем <code>0</code>, иначе из непустой строки «считывается» число. При ошибке результат <code>NaN</code>.</td>
</tr>
</tbody>
</table>

- <p><strong><code>Логическое</code></strong> – Происходит в логических операциях. Может быть вызвано с помощью <code>Boolean(value)</code>.</p>

Подчиняется правилам:

<table>
<thead>
<tr>
<th>Значение</th>
<th>Становится…</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>0</code>, <code>null</code>, <code>undefined</code>, <code>NaN</code>, <code>""</code></td>
<td><code>false</code></td>
</tr>
<tr>
<td>любое другое значение</td>
<td><code>true</code></td>
</tr>
</tbody>
</table>

## Ссылочные типы данных (объекты)

Мы говорили о примитивных типах данных, которые хранятся непосредственно в памяти, где к ним осуществляется доступ. Ссылочные типы работают немного по-другому под капотом. В основном существует 3 типа, которые передаются по ссылке

- `Arrays`
- `Functions`
- `Objects`

Технически, все это "объекты", что означает, что у них есть свойства и методы.

Ссылочные типы или "объекты" являются непримитивными значениями, и при присвоении переменной переменной присваивается **ссылка** на это значение. Ссылка указывает на местоположение объекта в памяти. В отличие от примитивов, где переменная содержит фактическое значение.

## Сборка мусора

Управление памятью в JavaScript выполняется автоматически и незаметно. Мы создаём примитивы, объекты, функции… Всё это занимает память.

<ul>
<li>Сборка мусора выполняется автоматически. Мы не можем ускорить или предотвратить её.</li>
<li>Объекты сохраняются в памяти, пока они достижимы.</li>
<li>Если на объект есть ссылка – вовсе не факт, что он является достижимым (из корня): набор взаимосвязанных объектов может стать недоступен в целом.</li>
</ul>

## Выделение памяти

Когда мы создаем переменную, движок JavaScript выделяет их в двух разных местах, называемых `стеком` и `кучей`.

Примитивные значения, такие как строки, числа и т. д., являются статическими и неизменными данными, которые фиксированы. Из-за этого размер данных вообще не меняется, поэтому память выделяется в виде фиксированного объема и хранится в стеке.

Например:

```JavaScript
const name = 'John';
const age = 30;
```

Cтек памяти:
<img src="/assets/images/theory/js/stack1.png" alt="" style="width:200px;"/>

Заметьте, что память была выделена в стеке для переменной и значения для имени и возраста. Это потому, что они являются статическими примитивными значениями.

Создадим объект **person** `object`

```JavaScript
const person = {
  name: 'Brad',
  age: 40
}
```

Поскольку это ссылочный тип, который не является статическим, и мы можем добавлять и удалять из него значения, объект хранится в куче:

<img src="/assets/images/theory/js/stack2.png" alt="" style="width:500px;"/>

Давайте установим новую переменную с именем **newName**, чтобы она ссылалась на примитивную переменную **name**:

```JavaScript
const newName = name;
```

Под капотом JavaScript копирует примитивное значение **John** и присваивает его **newName**:

<img src="/assets/images/theory/js/stack3.png" alt="" style="width:500px;"/>

Изменим значение **newName** на **Jonathan**

```JavaScript
newName = 'Jonathan'
```

<img src="/assets/images/theory/js/stack4.png" alt="" style="width:500px;"/>

Значение **name** остается прежним, и меняется только **newName**. Это потому, что оно было передано по значению.

Создадим новую переменную **newPerson** и установим ее равной **person**:

```JavaScript
const newPerson = person;
```

Теперь переменная **newPerson** ссылается на то же значение в куче.

<img src="/assets/images/theory/js/stack5.png" alt="" style="width:500px;"/>

Если обновить значение **name** объекта **newPerson** :

```JavaScript
newPerson.name = 'Bradley'
```

Это изменит ссылку в куче, и теперь и **person**, и **newPerson** будут иметь имя Bradley. Это происходит потому, что оно передается по ссылке.

<img src="/assets/images/theory/js/stack6.png" alt="" style="width:500px;"/>