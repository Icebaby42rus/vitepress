## Что такое DOM?

DOM, или Document Object Model, представляет собой структурированное представление документа веб-страницы в виде дерева объектов. Этот документ может быть написан с использованием языка разметки, такого как HTML. DOM предоставляет программам и скриптам возможность динамического доступа и изменения содержимого, структуры и стилей веб-страницы.

Вот некоторые ключевые аспекты DOM:

1. **Иерархия объектов:**
* Каждый элемент HTML или XML-документа представлен объектом в виде узла (node) в дереве DOM.
* Узлы могут быть элементами, атрибутами, текстовыми фрагментами и т.д.

2. **Доступ и Манипуляция:**
* DOM предоставляет интерфейс для доступа и манипуляции элементами документа с использованием различных методов и свойств.
* JavaScript является одним из наиболее распространенных языков программирования, используемых для работы с DOM в контексте веб-разработки.

3. **Структура дерева:**
* Дерево DOM начинается с корневого элемента (document), который содержит все другие элементы.
* Элементы располагаются вложенными друг в друга, формируя иерархию.

4. **Событий:**
* DOM также обеспечивает механизм обработки событий. События, такие как щелчок мыши или загрузка документа, могут быть обнаружены и обработаны с использованием JavaScript.

5. **Динамическое обновление:**
* DOM позволяет динамически обновлять содержимое страницы без необходимости перезагрузки всей страницы.
* Это позволяет создавать интерактивные и динамичные веб-приложения.

## Навигация по DOM-элементам

Все операции с DOM начинаются с объекта <code>document</code>. Это главная «точка входа» в DOM. Из него мы можем получить доступ к любому узлу.

Так выглядят основные ссылки, по которым можно переходить между узлами DOM:

![alt-текст](/assets/images/theory/js/dom.png)

### Сверху: documentElement и body

Самые верхние элементы дерева доступны как свойства объекта document:

<dl>
<dt><code>&lt;html&gt;</code> = <code>document.documentElement</code></dt>
<dd>Самый верхний узел документа: <code>document.documentElement</code>. В DOM он соответствует тегу <code>&lt;html&gt;</code>.</dd>
<br>
<dt><code>&lt;body&gt;</code> = <code>document.body</code></dt>
<dd>Другой часто используемый DOM-узел – узел тега <code>&lt;body&gt;</code>: <code>document.body</code>.</dd>
<br>
<dt><code>&lt;head&gt;</code> = <code>document.head</code></dt>
<dd>Тег <code>&lt;head&gt;</code> доступен как <code>document.head</code>.</dd>
</dl>

### Дети: childNodes, firstChild, lastChild

- *Дочерние узлы (или дети)* – элементы, которые являются непосредственными детьми узла. Другими словами, элементы, которые лежат непосредственно внутри данного. Например, 
<code>&lt;head&gt;</code> и <code>&lt;body&gt;</code> являются детьми элемента <code>&lt;html&gt;</code>.
- *Потомки* – все элементы, которые лежат внутри данного, включая детей, их детей и т.д.

**Коллекция <code>childNodes</code> содержит список всех детей, включая текстовые узлы.**

**Свойства <code>firstChild</code> и <code>lastChild</code> обеспечивают быстрый доступ к первому и последнему дочернему элементу.**

### DOM-коллекции

<code>childNodes</code> похож на массив. На самом деле это не массив, а коллекция – особый перебираемый объект-псевдомассив.

И есть два важных следствия из этого:

- Для перебора коллекции мы можем использовать for..of.
- Методы массивов не будут работать, потому что коллекция – это не массив.

### Соседи и родитель

*Соседи* – это узлы, у которых один и тот же родитель.

Следующий узел того же родителя (следующий сосед) – в свойстве <code>nextSibling</code>, а предыдущий – в <code>previousSibling</code>

Родитель доступен через <code>parentNode</code>.

### Навигация только по элементам

Навигационные свойства, описанные выше, относятся ко всем узлам в документе. В частности, в <code>childNodes</code> находятся и текстовые узлы и узлы-элементы и узлы-комментарии, если они есть.

Но для большинства задач текстовые узлы и узлы-комментарии нам не нужны. Мы хотим манипулировать узлами-элементами, которые представляют собой теги и формируют структуру страницы.

Эти ссылки похожи на те, что раньше, только в ряде мест стоит слово Element:

<ul>
<li><code>children</code> – коллекция детей, которые являются элементами.</li>
<li><code>firstElementChild</code>, <code>lastElementChild</code> – первый и последний дочерний элемент.</li>
<li><code>previousElementSibling</code>, <code>nextElementSibling</code> – соседи-элементы.</li>
<li><code>parentElement</code> – родитель-элемент.</li>
</ul>

## Поиск элементов

**document.getElementById или просто id**

Если у элемента есть атрибут <code>id</code>, то мы можем получить его вызовом <code>document.getElementById(id)</code>, где бы он ни находился.

**querySelectorAll**

Самый универсальный метод поиска – это <code>elem.querySelectorAll(css)</code>, он возвращает все элементы внутри <code>elem</code>, удовлетворяющие данному CSS-селектору.

**querySelector**

<p>Метод <code>elem.querySelector(css)</code> возвращает первый элемент, соответствующий данному CSS-селектору.</p>

**matches**

Метод <code>elem.matches(css)</code> ничего не ищет, а проверяет, удовлетворяет ли <code>elem</code> CSS-селектору, и возвращает <code>true</code> или <code>false</code>.

Этот метод удобен, когда мы перебираем элементы (например, в массиве или в чём-то подобном) и пытаемся выбрать те из них, которые нас интересуют.

**closest**

Предки элемента – родитель, родитель родителя, его родитель и так далее. Вместе они образуют цепочку иерархии от элемента до вершины.

Метод <code>elem.closest(css)</code> ищет ближайшего предка, который соответствует CSS-селектору. Сам элемент также включается в поиск.

Другими словами, метод <code>closest</code> поднимается вверх от элемента и проверяет каждого из родителей. Если он соответствует селектору, поиск прекращается. Метод возвращает либо предка, либо <code>null</code>, если такой элемент не найден.

**contains**

Метод, который проверяет наличие отношений между предком и потомком.
<code>elemA.contains(elemB)</code> вернёт <code>true</code>, если <code>elemB</code> находится внутри <code>elemA</code> (<code>elemB</code> потомок <code>elemA</code>) или когда <code>elemA==elemB</code>.

6 основных методов поиска элементов в DOM:

<table>
<thead>
<tr>
<td>Метод</td>
<td>Ищет по...</td>
<td>Ищет внутри элемента?</td>
<td>Возвращает живую коллекцию?</td>
</tr>
</thead>
<tbody>
<tr>
<td><code>querySelector</code></td>
<td>CSS-selector</td>
<td>✔</td>
<td>-</td>
</tr>
<tr>
<td><code>querySelectorAll</code></td>
<td>CSS-selector</td>
<td>✔</td>
<td>-</td>
</tr>
<tr>
<td><code>getElementById</code></td>
<td><code>id</code></td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td><code>getElementsByName</code></td>
<td><code>name</code></td>
<td>-</td>
<td>✔</td>
</tr>
<tr>
<td><code>getElementsByTagName</code></td>
<td>tag or <code>'*'</code></td>
<td>✔</td>
<td>✔</td>
</tr>
<tr>
<td><code>getElementsByClassName</code></td>
<td>class</td>
<td>✔</td>
<td>✔</td>
</tr>
</tbody>
</table>

## Свойства узлов: тип, тег и содержимое

**Классы DOM-узлов**

У разных DOM-узлов могут быть разные свойства. Например, у узла, соответствующего тегу <code>&lt;a&gt;</code>, есть свойства, связанные со ссылками, а у соответствующего тегу <code>&lt;input&gt;</code> – свойства, связанные с полем ввода и т.д. Текстовые узлы отличаются от узлов-элементов. Но у них есть общие свойства и методы, потому что все классы DOM-узлов образуют единую иерархию.

Каждый DOM-узел принадлежит соответствующему встроенному классу.

Корнем иерархии является EventTarget, от него наследует Node и остальные DOM-узлы.

![alt-текст](/assets/images/theory/js/dom2.png)

Существуют следующие классы:

<ul>
<li>
<p><code>EventTarget</code> – это корневой «абстрактный» класс для всего.</p>
<p>Объекты этого класса никогда не создаются. Он служит основой, благодаря которой все DOM-узлы поддерживают так называемые «события».</p>
</li>
<li>
<p><code>Node</code> – также является «абстрактным» классом, и служит основой для DOM-узлов.</p>
<p>Он обеспечивает базовую функциональность: <code>parentNode</code>, <code>nextSibling</code>, <code>childNodes</code> и т.д. (это геттеры). Объекты класса <code>Node</code> никогда не создаются. Но есть определённые классы узлов, которые наследуются от него (и следовательно наследуют функционал <code>Node</code>).</p>
</li>
<li>
<p><code>Document</code>, по историческим причинам часто наследуется <code>HTMLDocument</code> (хотя последняя спецификация этого не навязывает) – это документ в целом.</p>
<p>Глобальный объект <code>document</code> принадлежит именно к этому классу. Он служит точкой входа в DOM.</p>
</li>
<li>
<p><code>CharacterData</code> – «абстрактный» класс. Вот, кем он наследуется:</p>
<ul>
<li><code>Text</code> – класс, соответствующий тексту внутри элементов. Например, <code>Hello</code> в <code>&lt;p&gt;Hello&lt;/p&gt;</code>.</li>
<li><code>Comment</code> – класс для комментариев. Они не отображаются, но каждый комментарий становится членом DOM.</li>
</ul>
</li>
<li>
<p><code>Element</code> – это базовый класс для DOM-элементов.</p>
<p>Он обеспечивает навигацию на уровне элементов: <code>nextElementSibling</code>, <code>children</code>.
А также и методы поиска элементов: <code>getElementsByTagName</code>, <code>querySelector</code>.</p>
<p>Браузер поддерживает не только HTML, но также XML и SVG. Таким образом, класс <code>Element</code> служит основой для более специфичных классов: <code>SVGElement</code>, <code>XmlElement</code> (они нам здесь не нужны) и <code>HTMLElement</code>.</p>
</li>
<li>
<p>И наконец, <code>HTMLElement</code> является базовым классом для всех остальных HTML-элементов.</p>

<p>От него наследуются конкретные элементы:</p>
<ul>
<li><code>HTMLInputElement</code> – класс для тега <code>&lt;input&gt;</code>,</li>
<li><code>HTMLBodyElement</code> – класс для тега <code>&lt;body&gt;</code>,</li>
<li><code>HTMLAnchorElement</code> – класс для тега <code>&lt;a&gt;</code>,</li>
<li>…и т.д.</li>
</ul>
</li>
</ul>

Как видно, DOM-узлы – это обычные JavaScript объекты. Для наследования они используют классы, основанные на прототипах.
Каждый DOM-узел принадлежит определённому классу. Классы формируют иерархию. Весь набор свойств и методов является результатом наследования.

Главные свойства DOM-узла:

<dl>
<dt><code>nodeType</code></dt>
<dd>Свойство <code>nodeType</code> позволяет узнать тип DOM-узла. Его значение – числовое: <code>1</code> для элементов,<code>3</code> для текстовых узлов, и т.д. Только для чтения.</dd>
<br>
<dt><code>nodeName/tagName</code></dt>
<dd>Для элементов это свойство возвращает название тега (записывается в верхнем регистре, за исключением XML-режима). Для узлов-неэлементов <code>nodeName</code> описывает, что это за узел. Только для чтения.</dd>
<br>
<dt><code>innerHTML</code></dt>
<dd>Внутреннее HTML-содержимое узла-элемента. Можно изменять.</dd>
<br>
<dt><code>outerHTML</code></dt>
<dd>Полный HTML узла-элемента. Запись в <code>elem.outerHTML</code> не меняет <code>elem</code>. Вместо этого она заменяет его во внешнем контексте.</dd>
<br>
<dt><code>nodeValue/data</code></dt>
<dd>Содержимое узла-неэлемента (текст, комментарий). Эти свойства практически одинаковые, обычно мы используем <code>data</code>. Можно изменять.</dd>
<br>
<dt><code>textContent</code></dt>
<dd>Текст внутри элемента: HTML за вычетом всех <code>&lt;тегов&gt;</code>. Запись в него помещает текст в элемент, при этом все специальные символы и теги интерпретируются как текст. Можно использовать для защиты от вставки произвольного HTML кода.</dd>
<br>
<dt><code>hidden</code></dt>
<dd>Когда значение установлено в <code>true</code>, делает то же самое, что и CSS <code>display:none</code>.</dd>
</dl>

## Атрибуты и свойства

Когда браузер загружает страницу, он «читает» (также говорят: «парсит») HTML и генерирует из него DOM-объекты. Для узлов-элементов большинство стандартных HTML-атрибутов автоматически становятся свойствами DOM-объектов.

Например, для такого тега <code>&lt;body id="page"&gt;</code> у DOM-объекта будет такое свойство body.id="page".

**DOM-свойства**

DOM-узлы – это обычные объекты JavaScript. Мы можем их изменять.

**HTML-атрибуты**

В HTML у тегов могут быть атрибуты. Когда браузер парсит HTML, чтобы создать DOM-объекты для тегов, он распознаёт стандартные атрибуты и создаёт DOM-свойства для них.

Все атрибуты доступны с помощью следующих методов:

<ul>
<li><code>elem.hasAttribute(name)</code> – проверяет наличие атрибута.</li>
<li><code>elem.getAttribute(name)</code> – получает значение атрибута.</li>
<li><code>elem.setAttribute(name, value)</code> – устанавливает значение атрибута.</li>
<li><code>elem.removeAttribute(name)</code> – удаляет атрибут.</li>
</ul>

Эти методы работают именно с тем, что написано в HTML.

Кроме этого, получить все атрибуты элемента можно с помощью свойства <code>elem.attributes</code>: коллекция объектов, которая принадлежит ко встроенному классу <code>Attr</code> со свойствами <code>name</code> и <code>value</code>.

**Нестандартные атрибуты, dataset**

Иногда нестандартные атрибуты используются для передачи пользовательских данных из HTML в JavaScript, или чтобы «помечать» HTML-элементы для JavaScript.

Все атрибуты, начинающиеся с префикса «data-», зарезервированы для использования программистами. Они доступны в свойстве <code>dataset</code>.

Например, если у <code>elem</code> есть атрибут <code>"data-about"</code>, то обратиться к нему можно как <code>elem.dataset.about</code>.

Атрибуты, состоящие из нескольких слов, к примеру <code>data-order-state</code>, становятся свойствами, записанными с помощью верблюжьей нотации: <code>dataset.orderState</code>.

## Изменение документа

**Создание элемента**

DOM-узел можно создать двумя методами:

Создаёт новый *элемент* с заданным тегом:
<code>document.createElement(tag)</code>

Создаёт новый *текстовый узел* с заданным текстом:
<code>document.createTextNode(text)</code>

**Методы вставки**

Вот методы для различных вариантов вставки:

<ul>
<li><code>node.append(...nodes or strings)</code> – добавляет узлы или строки в конец <code>node</code>,</li>
<li><code>node.prepend(...nodes or strings)</code> – вставляет узлы или строки в начало <code>node</code>,</li>
<li><code>node.before(...nodes or strings)</code> –- вставляет узлы или строки до <code>node</code>,</li>
<li><code>node.after(...nodes or strings)</code> –- вставляет узлы или строки после <code>node</code>,</li>
<li><code>node.replaceWith(...nodes or strings)</code> –- заменяет <code>node</code> заданными узлами или строками.</li>
</ul>

![alt-текст](/assets/images/theory/js/dom3.png)

**insertAdjacentHTML/Text/Element**

Если мы хотим вставить HTML именно «как html», со всеми тегами и прочим - <code>elem.insertAdjacentHTML(where, html)</code>.

Первый параметр – это специальное слово, указывающее, куда по отношению к <code>elem</code> производить вставку. Значение должно быть одним из следующих:

<ul>
<li><code>"beforebegin"</code> – вставить <code>html</code> непосредственно перед <code>elem</code>,</li>
<li><code>"afterbegin"</code> – вставить <code>html</code> в начало <code>elem</code>,</li>
<li><code>"beforeend"</code> – вставить <code>html</code> в конец <code>elem</code>,</li>
<li><code>"afterend"</code> – вставить <code>html</code> непосредственно после <code>elem</code>.</li>
</ul>

Второй параметр – это HTML-строка, которая будет вставлена именно «как HTML».

**Удаление узлов**

Для удаления узла есть методы <code>node.remove()</code>.

**Клонирование узлов: cloneNode**

Вызов <code>elem.cloneNode(true)</code> создаёт «глубокий» клон элемента – со всеми атрибутами и дочерними элементами. Если мы вызовем <code>elem.cloneNode(false)</code>, тогда клон будет без дочерних элементов.

## Стили и классы

Классы – всегда предпочтительный вариант по сравнению со <code>style</code>. Мы должны манипулировать свойством <code>style</code> только в том случае, если классы «не могут справиться».

Например, использование <code>style</code> является приемлемым, если мы вычисляем координаты элемента динамически и хотим установить их из JavaScript.

Для управления классами существуют два DOM-свойства:

<ul>
<li><code>className</code> – строковое значение, удобно для управления всем набором классов.</li>
<li><code>classList</code> – объект с методами <code>add/remove/toggle/contains</code>, удобно для управления отдельными классами.</li>
</ul>

Чтобы изменить стили:

<ul>
<li>
Свойство <code>style</code> является объектом со стилями в формате camelCase. Чтение и запись в него работают так же, как изменение соответствующих свойств в атрибуте <code>"style"</code>.
</li>
<li>
Свойство <code>style.cssText</code> соответствует всему атрибуту <code>"style"</code>, полной строке стилей.
</li>
</ul>
