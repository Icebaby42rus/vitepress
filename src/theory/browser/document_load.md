## Загрузка документа и ресурсов

У жизненного цикла HTML-страницы есть три важных события:

<ul>
<li><code>DOMContentLoaded</code> – браузер полностью загрузил HTML, было построено DOM-дерево, но внешние ресурсы, такие как картинки <code>&lt;img&gt;</code> и стили, могут быть ещё не загружены.</li>
<li><code>load</code> – браузер загрузил HTML и внешние ресурсы (картинки, стили и т.д.).</li>
<li><code>beforeunload/unload</code> – пользователь покидает страницу.</li>
</ul>

Каждое из этих событий может быть полезно:

<ul>
<li>Событие <code>DOMContentLoaded</code> – DOM готов, так что обработчик может искать DOM-узлы и инициализировать интерфейс.</li>
<li>Событие <code>load</code> – внешние ресурсы были загружены, стили применены, размеры картинок известны и т.д.</li>
<li>Событие <code>beforeunload</code> – пользователь покидает страницу. Мы можем проверить, сохранил ли он изменения и спросить, на самом ли деле он хочет уйти.</li>
<li><code>unload</code> – пользователь почти ушёл, но мы всё ещё можем запустить некоторые операции, например, отправить статистику.</li>
</ul>

## readyState

<p>Свойство <code>document.readyState</code> показывает нам текущее состояние загрузки.</p>

<ul>
<li><code>"loading"</code> – документ загружается.</li>
<li><code>"interactive"</code> – документ был полностью прочитан.</li>
<li><code>"complete"</code> – документ был полностью прочитан и все ресурсы (такие как изображения) были тоже загружены.</li>
</ul>

## Скрипты: async, defer

<p>Когда браузер загружает HTML и доходит до тега <code>&lt;script&gt;...&lt;/script&gt;</code>, он не может продолжать строить DOM. Он должен сначала выполнить скрипт. То же самое происходит и с внешними скриптами <code>&lt;script src="..."&gt;&lt;/script&gt;</code>: браузер должен подождать, пока загрузится скрипт, выполнить его, и только затем обработать остальную страницу.</p>

Это ведёт к двум важным проблемам:

<ol>
<li>Скрипты не видят DOM-элементы ниже себя, поэтому к ним нельзя добавить обработчики и т.д.</li>
<li>Если вверху страницы объёмный скрипт, он «блокирует» страницу. Пользователи не видят содержимое страницы, пока он не загрузится и не запустится:</li>
</ol>

<p>Есть два атрибута тега <code>&lt;script&gt;</code>, которые решают проблему: <code>defer</code> и <code>async</code>.</p>

### defer

<p>Атрибут <code>defer</code> сообщает браузеру, что он должен продолжать обрабатывать страницу и загружать скрипт в фоновом режиме, а затем запустить этот скрипт, когда DOM дерево будет полностью построено.</p>

<ul>
<li>Скрипты с <code>defer</code> никогда не блокируют страницу.</li>
<li>Скрипты с  <code>defer</code> всегда выполняются, когда дерево DOM готово, но до события <code>DOMContentLoaded</code>.</li>
</ul>

<p><strong>Отложенные с помощью <code>defer</code> скрипты сохраняют порядок относительно друг друга, как и обычные скрипты.</strong></p>

<p>Допустим, у нас есть два скрипта c <code>defer</code>: <code>small.js</code> и <code>long.js</code>:</p>

```js
<script defer src="https://javascript.info/article/script-async-defer/long.js"></script>
<script defer src="https://javascript.info/article/script-async-defer/small.js"></script>
```

<p>Браузеры сканируют страницу на предмет скриптов и загружают их параллельно в целях увеличения производительности. Поэтому и в примере выше оба скрипта скачиваются параллельно. <code>small.js</code> скорее всего загрузится первым.</p>

<p>…Но <code>defer</code> не только говорит браузеру «не блокировать рендеринг», он также обеспечивает правильную последовательность выполнения скриптов. Даже если <code>small.js</code> загрузится первым, он будет ждать выполнения <code>long.js</code>.</p>

Это важно в тех случаях, когда нам сначала нужно загрузить JavaScript-библиотеку, а затем скрипт, который от неё зависит.

Атрибут ***defer*** предназначен только для внешних скриптов(<p>Атрибут <code>defer</code> будет проигнорирован, если в теге <code>&lt;script&gt;</code> нет <code>src</code>.</p>).

### async

<p>Атрибут <code>async</code> означает, что скрипт абсолютно независим:</p>

<ul>
<li>Страница не ждёт асинхронных скриптов, содержимое обрабатывается и отображается.</li>
<li>Событие <code>DOMContentLoaded</code> и асинхронные скрипты не ждут друг друга:
<ul>
<li><code>DOMContentLoaded</code> может произойти как до асинхронного скрипта (если асинхронный скрипт завершит загрузку после того, как страница будет готова),</li>
<li>…так и после асинхронного скрипта (если он короткий или уже содержится в HTTP-кеше)</li>
</ul>
</li>
<li>Остальные скрипты не ждут <code>async</code>, и скрипты c<code>async</code> не ждут другие скрипты.</li>
</ul>

Так что если у нас есть несколько скриптов с async, они могут выполняться в любом порядке. То, что первое загрузится – запустится в первую очередь.

Асинхронные скрипты очень полезны для добавления на страницу сторонних скриптов: счётчиков, рекламы и т.д. Они не зависят от наших скриптов, и мы тоже не должны ждать их.

Атрибут ***async*** предназначен только для внешних скриптов(<p>Атрибут <code>async</code> будет проигнорирован, если в теге <code>&lt;script&gt;</code> нет <code>src</code>.</p>).

### async vs defer

<p>У <code>async</code> и <code>defer</code> есть кое-что общее: они не блокируют отрисовку страницы. Так что пользователь может просмотреть содержимое страницы и ознакомиться с ней сразу же.</p>

## Динамически загружаемые скрипты

Мы можем также добавить скрипт и динамически, с помощью JavaScript:

```js
let script = document.createElement('script');
script.src = "/article/script-async-defer/long.js";
document.body.append(script); // (*)
```

<p>Скрипт начнёт загружаться, как только он будет добавлен в документ  <code>(*)</code>.</p>

<p><strong>Динамически загружаемые скрипты по умолчанию ведут себя как «async».</strong></p>

То есть:

<ul>
<li>Они никого не ждут, и их никто не ждёт.</li>
<li>Скрипт, который загружается первым – запускается первым (в порядке загрузки).</li>
</ul>


<table>
<thead>
<tr>
<th></th>
<th>Порядок</th>
<th><code>DOMContentLoaded</code></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>async</code></td>
<td><em>Порядок загрузки</em> (кто загрузится первым, тот и сработает).</td>
<td>Не имеет значения. Может загрузиться и выполниться до того, как страница полностью загрузится. Такое случается, если скрипты маленькие или хранятся в кеше, а документ достаточно большой.</td>
</tr>
<tr>
<td><code>defer</code></td>
<td><em>Порядок документа</em> (как расположены в документе).</td>
<td>Выполняется после того, как документ загружен и обработан  (ждёт), непосредственно перед <code>DOMContentLoaded</code>.</td>
</tr>
</tbody>
</table>

## Загрузка ресурсов: onload и onerror

Браузер позволяет отслеживать загрузку сторонних ресурсов: скриптов, ифреймов, изображений и др.

Для этого существуют два события:

<ul>
<li><code>load</code> – успешная загрузка,</li>
<li><code>error</code> – во время загрузки произошла ошибка.</li>
</ul>

<p>Изображения <code>&lt;img&gt;</code>, внешние стили, скрипты и другие ресурсы предоставляют события <code>load</code> и <code>error</code> для отслеживания загрузки.</p>